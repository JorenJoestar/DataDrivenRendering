// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RENDERDEFINITIONS_RENDERING_H_
#define FLATBUFFERS_GENERATED_RENDERDEFINITIONS_RENDERING_H_

#include "flatbuffers/flatbuffers.h"

namespace rendering {

struct DepthStencilOperation;

struct RenderTargetBlend;

struct DepthStencilState;

struct RasterizerState;

struct BlendState;

struct PipelineState;

struct RenderTarget;

struct RenderPipeline;

inline const flatbuffers::TypeTable *DepthStencilOperationTypeTable();

inline const flatbuffers::TypeTable *RenderTargetBlendTypeTable();

inline const flatbuffers::TypeTable *DepthStencilStateTypeTable();

inline const flatbuffers::TypeTable *RasterizerStateTypeTable();

inline const flatbuffers::TypeTable *BlendStateTypeTable();

inline const flatbuffers::TypeTable *PipelineStateTypeTable();

inline const flatbuffers::TypeTable *RenderTargetTypeTable();

inline const flatbuffers::TypeTable *RenderPipelineTypeTable();

/////////////////////////////////////////////////////////////////////////////////
enum Blend {
  Blend_Zero = 0,
  Blend_One = 1,
  Blend_SrcColor = 2,
  Blend_InvSrcColor = 3,
  Blend_SrcAlpha = 4,
  Blend_InvSrcAlpha = 5,
  Blend_DestAlpha = 6,
  Blend_InvDestAlpha = 7,
  Blend_DestColor = 8,
  Blend_InvDestColor = 9,
  Blend_SrcAlphaSta = 10,
  Blend_BlendFactor = 11,
  Blend_InvBlendFactor = 12,
  Blend_Src1Color = 13,
  Blend_InvSrc1Color = 14,
  Blend_Src1Alpha = 15,
  Blend_InvSrc1Alpha = 16,
  Blend_MIN = Blend_Zero,
  Blend_MAX = Blend_InvSrc1Alpha
};

inline const Blend (&EnumValuesBlend())[17] {
  static const Blend values[] = {
    Blend_Zero,
    Blend_One,
    Blend_SrcColor,
    Blend_InvSrcColor,
    Blend_SrcAlpha,
    Blend_InvSrcAlpha,
    Blend_DestAlpha,
    Blend_InvDestAlpha,
    Blend_DestColor,
    Blend_InvDestColor,
    Blend_SrcAlphaSta,
    Blend_BlendFactor,
    Blend_InvBlendFactor,
    Blend_Src1Color,
    Blend_InvSrc1Color,
    Blend_Src1Alpha,
    Blend_InvSrc1Alpha
  };
  return values;
}

inline const char * const *EnumNamesBlend() {
  static const char * const names[] = {
    "Zero",
    "One",
    "SrcColor",
    "InvSrcColor",
    "SrcAlpha",
    "InvSrcAlpha",
    "DestAlpha",
    "InvDestAlpha",
    "DestColor",
    "InvDestColor",
    "SrcAlphaSta",
    "BlendFactor",
    "InvBlendFactor",
    "Src1Color",
    "InvSrc1Color",
    "Src1Alpha",
    "InvSrc1Alpha",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlend(Blend e) {
  if (e < Blend_Zero || e > Blend_InvSrc1Alpha) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlend()[index];
}

enum BlendOperation {
  BlendOperation_Add = 0,
  BlendOperation_Subtract = 1,
  BlendOperation_RevSubtract = 2,
  BlendOperation_Min = 3,
  BlendOperation_Max = 4,
  BlendOperation_MIN = BlendOperation_Add,
  BlendOperation_MAX = BlendOperation_Max
};

inline const BlendOperation (&EnumValuesBlendOperation())[5] {
  static const BlendOperation values[] = {
    BlendOperation_Add,
    BlendOperation_Subtract,
    BlendOperation_RevSubtract,
    BlendOperation_Min,
    BlendOperation_Max
  };
  return values;
}

inline const char * const *EnumNamesBlendOperation() {
  static const char * const names[] = {
    "Add",
    "Subtract",
    "RevSubtract",
    "Min",
    "Max",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendOperation(BlendOperation e) {
  if (e < BlendOperation_Add || e > BlendOperation_Max) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlendOperation()[index];
}

enum ColorWriteEnabled {
  ColorWriteEnabled_Red = 0,
  ColorWriteEnabled_Green = 1,
  ColorWriteEnabled_Blue = 2,
  ColorWriteEnabled_Alpha = 3,
  ColorWriteEnabled_All = 4,
  ColorWriteEnabled_MIN = ColorWriteEnabled_Red,
  ColorWriteEnabled_MAX = ColorWriteEnabled_All
};

inline const ColorWriteEnabled (&EnumValuesColorWriteEnabled())[5] {
  static const ColorWriteEnabled values[] = {
    ColorWriteEnabled_Red,
    ColorWriteEnabled_Green,
    ColorWriteEnabled_Blue,
    ColorWriteEnabled_Alpha,
    ColorWriteEnabled_All
  };
  return values;
}

inline const char * const *EnumNamesColorWriteEnabled() {
  static const char * const names[] = {
    "Red",
    "Green",
    "Blue",
    "Alpha",
    "All",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorWriteEnabled(ColorWriteEnabled e) {
  if (e < ColorWriteEnabled_Red || e > ColorWriteEnabled_All) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColorWriteEnabled()[index];
}

enum ComparisonFunction {
  ComparisonFunction_Never = 0,
  ComparisonFunction_Less = 1,
  ComparisonFunction_Equal = 2,
  ComparisonFunction_LessEqual = 3,
  ComparisonFunction_Greater = 4,
  ComparisonFunction_NotEqual = 5,
  ComparisonFunction_GreaterEqual = 6,
  ComparisonFunction_Always = 7,
  ComparisonFunction_MIN = ComparisonFunction_Never,
  ComparisonFunction_MAX = ComparisonFunction_Always
};

inline const ComparisonFunction (&EnumValuesComparisonFunction())[8] {
  static const ComparisonFunction values[] = {
    ComparisonFunction_Never,
    ComparisonFunction_Less,
    ComparisonFunction_Equal,
    ComparisonFunction_LessEqual,
    ComparisonFunction_Greater,
    ComparisonFunction_NotEqual,
    ComparisonFunction_GreaterEqual,
    ComparisonFunction_Always
  };
  return values;
}

inline const char * const *EnumNamesComparisonFunction() {
  static const char * const names[] = {
    "Never",
    "Less",
    "Equal",
    "LessEqual",
    "Greater",
    "NotEqual",
    "GreaterEqual",
    "Always",
    nullptr
  };
  return names;
}

inline const char *EnumNameComparisonFunction(ComparisonFunction e) {
  if (e < ComparisonFunction_Never || e > ComparisonFunction_Always) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComparisonFunction()[index];
}

enum CullMode {
  CullMode_None = 0,
  CullMode_Front = 1,
  CullMode_Back = 2,
  CullMode_MIN = CullMode_None,
  CullMode_MAX = CullMode_Back
};

inline const CullMode (&EnumValuesCullMode())[3] {
  static const CullMode values[] = {
    CullMode_None,
    CullMode_Front,
    CullMode_Back
  };
  return values;
}

inline const char * const *EnumNamesCullMode() {
  static const char * const names[] = {
    "None",
    "Front",
    "Back",
    nullptr
  };
  return names;
}

inline const char *EnumNameCullMode(CullMode e) {
  if (e < CullMode_None || e > CullMode_Back) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCullMode()[index];
}

enum DepthWriteMask {
  DepthWriteMask_Zero = 0,
  DepthWriteMask_All = 1,
  DepthWriteMask_MIN = DepthWriteMask_Zero,
  DepthWriteMask_MAX = DepthWriteMask_All
};

inline const DepthWriteMask (&EnumValuesDepthWriteMask())[2] {
  static const DepthWriteMask values[] = {
    DepthWriteMask_Zero,
    DepthWriteMask_All
  };
  return values;
}

inline const char * const *EnumNamesDepthWriteMask() {
  static const char * const names[] = {
    "Zero",
    "All",
    nullptr
  };
  return names;
}

inline const char *EnumNameDepthWriteMask(DepthWriteMask e) {
  if (e < DepthWriteMask_Zero || e > DepthWriteMask_All) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDepthWriteMask()[index];
}

enum FillMode {
  FillMode_Wireframe = 0,
  FillMode_Solid = 1,
  FillMode_Point = 2,
  FillMode_MIN = FillMode_Wireframe,
  FillMode_MAX = FillMode_Point
};

inline const FillMode (&EnumValuesFillMode())[3] {
  static const FillMode values[] = {
    FillMode_Wireframe,
    FillMode_Solid,
    FillMode_Point
  };
  return values;
}

inline const char * const *EnumNamesFillMode() {
  static const char * const names[] = {
    "Wireframe",
    "Solid",
    "Point",
    nullptr
  };
  return names;
}

inline const char *EnumNameFillMode(FillMode e) {
  if (e < FillMode_Wireframe || e > FillMode_Point) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFillMode()[index];
}

enum FrontClockwise {
  FrontClockwise_True = 0,
  FrontClockwise_False = 1,
  FrontClockwise_MIN = FrontClockwise_True,
  FrontClockwise_MAX = FrontClockwise_False
};

inline const FrontClockwise (&EnumValuesFrontClockwise())[2] {
  static const FrontClockwise values[] = {
    FrontClockwise_True,
    FrontClockwise_False
  };
  return values;
}

inline const char * const *EnumNamesFrontClockwise() {
  static const char * const names[] = {
    "True",
    "False",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrontClockwise(FrontClockwise e) {
  if (e < FrontClockwise_True || e > FrontClockwise_False) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFrontClockwise()[index];
}

enum StencilOperation {
  StencilOperation_Keep = 0,
  StencilOperation_Zero = 1,
  StencilOperation_Replace = 2,
  StencilOperation_IncrSat = 3,
  StencilOperation_DecrSat = 4,
  StencilOperation_Invert = 5,
  StencilOperation_Incr = 6,
  StencilOperation_Decr = 7,
  StencilOperation_MIN = StencilOperation_Keep,
  StencilOperation_MAX = StencilOperation_Decr
};

inline const StencilOperation (&EnumValuesStencilOperation())[8] {
  static const StencilOperation values[] = {
    StencilOperation_Keep,
    StencilOperation_Zero,
    StencilOperation_Replace,
    StencilOperation_IncrSat,
    StencilOperation_DecrSat,
    StencilOperation_Invert,
    StencilOperation_Incr,
    StencilOperation_Decr
  };
  return values;
}

inline const char * const *EnumNamesStencilOperation() {
  static const char * const names[] = {
    "Keep",
    "Zero",
    "Replace",
    "IncrSat",
    "DecrSat",
    "Invert",
    "Incr",
    "Decr",
    nullptr
  };
  return names;
}

inline const char *EnumNameStencilOperation(StencilOperation e) {
  if (e < StencilOperation_Keep || e > StencilOperation_Decr) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStencilOperation()[index];
}

enum TextureFormat {
  TextureFormat_UNKNOWN = 0,
  TextureFormat_R32G32B32A32_TYPELESS = 1,
  TextureFormat_R32G32B32A32_FLOAT = 2,
  TextureFormat_R32G32B32A32_UINT = 3,
  TextureFormat_R32G32B32A32_SINT = 4,
  TextureFormat_R32G32B32_TYPELESS = 5,
  TextureFormat_R32G32B32_FLOAT = 6,
  TextureFormat_R32G32B32_UINT = 7,
  TextureFormat_R32G32B32_SINT = 8,
  TextureFormat_R16G16B16A16_TYPELESS = 9,
  TextureFormat_R16G16B16A16_FLOAT = 10,
  TextureFormat_R16G16B16A16_UNORM = 11,
  TextureFormat_R16G16B16A16_UINT = 12,
  TextureFormat_R16G16B16A16_SNORM = 13,
  TextureFormat_R16G16B16A16_SINT = 14,
  TextureFormat_R32G32_TYPELESS = 15,
  TextureFormat_R32G32_FLOAT = 16,
  TextureFormat_R32G32_UINT = 17,
  TextureFormat_R32G32_SINT = 18,
  TextureFormat_R10G10B10A2_TYPELESS = 19,
  TextureFormat_R10G10B10A2_UNORM = 20,
  TextureFormat_R10G10B10A2_UINT = 21,
  TextureFormat_R11G11B10_FLOAT = 22,
  TextureFormat_R8G8B8A8_TYPELESS = 23,
  TextureFormat_R8G8B8A8_UNORM = 24,
  TextureFormat_R8G8B8A8_UNORM_SRGB = 25,
  TextureFormat_R8G8B8A8_UINT = 26,
  TextureFormat_R8G8B8A8_SNORM = 27,
  TextureFormat_R8G8B8A8_SINT = 28,
  TextureFormat_R16G16_TYPELESS = 29,
  TextureFormat_R16G16_FLOAT = 30,
  TextureFormat_R16G16_UNORM = 31,
  TextureFormat_R16G16_UINT = 32,
  TextureFormat_R16G16_SNORM = 33,
  TextureFormat_R16G16_SINT = 34,
  TextureFormat_R32_TYPELESS = 35,
  TextureFormat_R32_FLOAT = 36,
  TextureFormat_R32_UINT = 37,
  TextureFormat_R32_SINT = 38,
  TextureFormat_R8G8_TYPELESS = 39,
  TextureFormat_R8G8_UNORM = 40,
  TextureFormat_R8G8_UINT = 41,
  TextureFormat_R8G8_SNORM = 42,
  TextureFormat_R8G8_SINT = 43,
  TextureFormat_R16_TYPELESS = 44,
  TextureFormat_R16_FLOAT = 45,
  TextureFormat_R16_UNORM = 46,
  TextureFormat_R16_UINT = 47,
  TextureFormat_R16_SNORM = 48,
  TextureFormat_R16_SINT = 49,
  TextureFormat_R8_TYPELESS = 50,
  TextureFormat_R8_UNORM = 51,
  TextureFormat_R8_UINT = 52,
  TextureFormat_R8_SNORM = 53,
  TextureFormat_R8_SINT = 54,
  TextureFormat_R9G9B9E5_SHAREDEXP = 55,
  TextureFormat_D32_FLOAT_S8X24_UINT = 56,
  TextureFormat_D32_FLOAT = 57,
  TextureFormat_D24_UNORM_S8_UINT = 58,
  TextureFormat_D24_UNORM_X8_UINT = 59,
  TextureFormat_D16_UNORM = 60,
  TextureFormat_S8_UINT = 61,
  TextureFormat_BC1_TYPELESS = 62,
  TextureFormat_BC1_UNORM = 63,
  TextureFormat_BC1_UNORM_SRGB = 64,
  TextureFormat_BC2_TYPELESS = 65,
  TextureFormat_BC2_UNORM = 66,
  TextureFormat_BC2_UNORM_SRGB = 67,
  TextureFormat_BC3_TYPELESS = 68,
  TextureFormat_BC3_UNORM = 69,
  TextureFormat_BC3_UNORM_SRGB = 70,
  TextureFormat_BC4_TYPELESS = 71,
  TextureFormat_BC4_UNORM = 72,
  TextureFormat_BC4_SNORM = 73,
  TextureFormat_BC5_TYPELESS = 74,
  TextureFormat_BC5_UNORM = 75,
  TextureFormat_BC5_SNORM = 76,
  TextureFormat_B5G6R5_UNORM = 77,
  TextureFormat_B5G5R5A1_UNORM = 78,
  TextureFormat_B8G8R8A8_UNORM = 79,
  TextureFormat_B8G8R8X8_UNORM = 80,
  TextureFormat_R10G10B10_XR_BIAS_A2_UNORM = 81,
  TextureFormat_B8G8R8A8_TYPELESS = 82,
  TextureFormat_B8G8R8A8_UNORM_SRGB = 83,
  TextureFormat_B8G8R8X8_TYPELESS = 84,
  TextureFormat_B8G8R8X8_UNORM_SRGB = 85,
  TextureFormat_BC6H_TYPELESS = 86,
  TextureFormat_BC6H_UF16 = 87,
  TextureFormat_BC6H_SF16 = 88,
  TextureFormat_BC7_TYPELESS = 89,
  TextureFormat_BC7_UNORM = 90,
  TextureFormat_BC7_UNORM_SRGB = 91,
  TextureFormat_FORCE_UINT = 92,
  TextureFormat_MIN = TextureFormat_UNKNOWN,
  TextureFormat_MAX = TextureFormat_FORCE_UINT
};

inline const TextureFormat (&EnumValuesTextureFormat())[93] {
  static const TextureFormat values[] = {
    TextureFormat_UNKNOWN,
    TextureFormat_R32G32B32A32_TYPELESS,
    TextureFormat_R32G32B32A32_FLOAT,
    TextureFormat_R32G32B32A32_UINT,
    TextureFormat_R32G32B32A32_SINT,
    TextureFormat_R32G32B32_TYPELESS,
    TextureFormat_R32G32B32_FLOAT,
    TextureFormat_R32G32B32_UINT,
    TextureFormat_R32G32B32_SINT,
    TextureFormat_R16G16B16A16_TYPELESS,
    TextureFormat_R16G16B16A16_FLOAT,
    TextureFormat_R16G16B16A16_UNORM,
    TextureFormat_R16G16B16A16_UINT,
    TextureFormat_R16G16B16A16_SNORM,
    TextureFormat_R16G16B16A16_SINT,
    TextureFormat_R32G32_TYPELESS,
    TextureFormat_R32G32_FLOAT,
    TextureFormat_R32G32_UINT,
    TextureFormat_R32G32_SINT,
    TextureFormat_R10G10B10A2_TYPELESS,
    TextureFormat_R10G10B10A2_UNORM,
    TextureFormat_R10G10B10A2_UINT,
    TextureFormat_R11G11B10_FLOAT,
    TextureFormat_R8G8B8A8_TYPELESS,
    TextureFormat_R8G8B8A8_UNORM,
    TextureFormat_R8G8B8A8_UNORM_SRGB,
    TextureFormat_R8G8B8A8_UINT,
    TextureFormat_R8G8B8A8_SNORM,
    TextureFormat_R8G8B8A8_SINT,
    TextureFormat_R16G16_TYPELESS,
    TextureFormat_R16G16_FLOAT,
    TextureFormat_R16G16_UNORM,
    TextureFormat_R16G16_UINT,
    TextureFormat_R16G16_SNORM,
    TextureFormat_R16G16_SINT,
    TextureFormat_R32_TYPELESS,
    TextureFormat_R32_FLOAT,
    TextureFormat_R32_UINT,
    TextureFormat_R32_SINT,
    TextureFormat_R8G8_TYPELESS,
    TextureFormat_R8G8_UNORM,
    TextureFormat_R8G8_UINT,
    TextureFormat_R8G8_SNORM,
    TextureFormat_R8G8_SINT,
    TextureFormat_R16_TYPELESS,
    TextureFormat_R16_FLOAT,
    TextureFormat_R16_UNORM,
    TextureFormat_R16_UINT,
    TextureFormat_R16_SNORM,
    TextureFormat_R16_SINT,
    TextureFormat_R8_TYPELESS,
    TextureFormat_R8_UNORM,
    TextureFormat_R8_UINT,
    TextureFormat_R8_SNORM,
    TextureFormat_R8_SINT,
    TextureFormat_R9G9B9E5_SHAREDEXP,
    TextureFormat_D32_FLOAT_S8X24_UINT,
    TextureFormat_D32_FLOAT,
    TextureFormat_D24_UNORM_S8_UINT,
    TextureFormat_D24_UNORM_X8_UINT,
    TextureFormat_D16_UNORM,
    TextureFormat_S8_UINT,
    TextureFormat_BC1_TYPELESS,
    TextureFormat_BC1_UNORM,
    TextureFormat_BC1_UNORM_SRGB,
    TextureFormat_BC2_TYPELESS,
    TextureFormat_BC2_UNORM,
    TextureFormat_BC2_UNORM_SRGB,
    TextureFormat_BC3_TYPELESS,
    TextureFormat_BC3_UNORM,
    TextureFormat_BC3_UNORM_SRGB,
    TextureFormat_BC4_TYPELESS,
    TextureFormat_BC4_UNORM,
    TextureFormat_BC4_SNORM,
    TextureFormat_BC5_TYPELESS,
    TextureFormat_BC5_UNORM,
    TextureFormat_BC5_SNORM,
    TextureFormat_B5G6R5_UNORM,
    TextureFormat_B5G5R5A1_UNORM,
    TextureFormat_B8G8R8A8_UNORM,
    TextureFormat_B8G8R8X8_UNORM,
    TextureFormat_R10G10B10_XR_BIAS_A2_UNORM,
    TextureFormat_B8G8R8A8_TYPELESS,
    TextureFormat_B8G8R8A8_UNORM_SRGB,
    TextureFormat_B8G8R8X8_TYPELESS,
    TextureFormat_B8G8R8X8_UNORM_SRGB,
    TextureFormat_BC6H_TYPELESS,
    TextureFormat_BC6H_UF16,
    TextureFormat_BC6H_SF16,
    TextureFormat_BC7_TYPELESS,
    TextureFormat_BC7_UNORM,
    TextureFormat_BC7_UNORM_SRGB,
    TextureFormat_FORCE_UINT
  };
  return values;
}

inline const char * const *EnumNamesTextureFormat() {
  static const char * const names[] = {
    "UNKNOWN",
    "R32G32B32A32_TYPELESS",
    "R32G32B32A32_FLOAT",
    "R32G32B32A32_UINT",
    "R32G32B32A32_SINT",
    "R32G32B32_TYPELESS",
    "R32G32B32_FLOAT",
    "R32G32B32_UINT",
    "R32G32B32_SINT",
    "R16G16B16A16_TYPELESS",
    "R16G16B16A16_FLOAT",
    "R16G16B16A16_UNORM",
    "R16G16B16A16_UINT",
    "R16G16B16A16_SNORM",
    "R16G16B16A16_SINT",
    "R32G32_TYPELESS",
    "R32G32_FLOAT",
    "R32G32_UINT",
    "R32G32_SINT",
    "R10G10B10A2_TYPELESS",
    "R10G10B10A2_UNORM",
    "R10G10B10A2_UINT",
    "R11G11B10_FLOAT",
    "R8G8B8A8_TYPELESS",
    "R8G8B8A8_UNORM",
    "R8G8B8A8_UNORM_SRGB",
    "R8G8B8A8_UINT",
    "R8G8B8A8_SNORM",
    "R8G8B8A8_SINT",
    "R16G16_TYPELESS",
    "R16G16_FLOAT",
    "R16G16_UNORM",
    "R16G16_UINT",
    "R16G16_SNORM",
    "R16G16_SINT",
    "R32_TYPELESS",
    "R32_FLOAT",
    "R32_UINT",
    "R32_SINT",
    "R8G8_TYPELESS",
    "R8G8_UNORM",
    "R8G8_UINT",
    "R8G8_SNORM",
    "R8G8_SINT",
    "R16_TYPELESS",
    "R16_FLOAT",
    "R16_UNORM",
    "R16_UINT",
    "R16_SNORM",
    "R16_SINT",
    "R8_TYPELESS",
    "R8_UNORM",
    "R8_UINT",
    "R8_SNORM",
    "R8_SINT",
    "R9G9B9E5_SHAREDEXP",
    "D32_FLOAT_S8X24_UINT",
    "D32_FLOAT",
    "D24_UNORM_S8_UINT",
    "D24_UNORM_X8_UINT",
    "D16_UNORM",
    "S8_UINT",
    "BC1_TYPELESS",
    "BC1_UNORM",
    "BC1_UNORM_SRGB",
    "BC2_TYPELESS",
    "BC2_UNORM",
    "BC2_UNORM_SRGB",
    "BC3_TYPELESS",
    "BC3_UNORM",
    "BC3_UNORM_SRGB",
    "BC4_TYPELESS",
    "BC4_UNORM",
    "BC4_SNORM",
    "BC5_TYPELESS",
    "BC5_UNORM",
    "BC5_SNORM",
    "B5G6R5_UNORM",
    "B5G5R5A1_UNORM",
    "B8G8R8A8_UNORM",
    "B8G8R8X8_UNORM",
    "R10G10B10_XR_BIAS_A2_UNORM",
    "B8G8R8A8_TYPELESS",
    "B8G8R8A8_UNORM_SRGB",
    "B8G8R8X8_TYPELESS",
    "B8G8R8X8_UNORM_SRGB",
    "BC6H_TYPELESS",
    "BC6H_UF16",
    "BC6H_SF16",
    "BC7_TYPELESS",
    "BC7_UNORM",
    "BC7_UNORM_SRGB",
    "FORCE_UINT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFormat(TextureFormat e) {
  if (e < TextureFormat_UNKNOWN || e > TextureFormat_FORCE_UINT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureFormat()[index];
}

enum TopologyType {
  TopologyType_Unknown = 0,
  TopologyType_Point = 1,
  TopologyType_Line = 2,
  TopologyType_Triangle = 3,
  TopologyType_Patch = 4,
  TopologyType_MIN = TopologyType_Unknown,
  TopologyType_MAX = TopologyType_Patch
};

inline const TopologyType (&EnumValuesTopologyType())[5] {
  static const TopologyType values[] = {
    TopologyType_Unknown,
    TopologyType_Point,
    TopologyType_Line,
    TopologyType_Triangle,
    TopologyType_Patch
  };
  return values;
}

inline const char * const *EnumNamesTopologyType() {
  static const char * const names[] = {
    "Unknown",
    "Point",
    "Line",
    "Triangle",
    "Patch",
    nullptr
  };
  return names;
}

inline const char *EnumNameTopologyType(TopologyType e) {
  if (e < TopologyType_Unknown || e > TopologyType_Patch) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTopologyType()[index];
}

enum BufferType {
  BufferType_Vertex = 0,
  BufferType_Index = 1,
  BufferType_Constant = 2,
  BufferType_Indirect = 3,
  BufferType_MIN = BufferType_Vertex,
  BufferType_MAX = BufferType_Indirect
};

inline const BufferType (&EnumValuesBufferType())[4] {
  static const BufferType values[] = {
    BufferType_Vertex,
    BufferType_Index,
    BufferType_Constant,
    BufferType_Indirect
  };
  return values;
}

inline const char * const *EnumNamesBufferType() {
  static const char * const names[] = {
    "Vertex",
    "Index",
    "Constant",
    "Indirect",
    nullptr
  };
  return names;
}

inline const char *EnumNameBufferType(BufferType e) {
  if (e < BufferType_Vertex || e > BufferType_Indirect) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBufferType()[index];
}

enum ResourceUsageType {
  ResourceUsageType_Immutable = 0,
  ResourceUsageType_Dynamic = 1,
  ResourceUsageType_Stream = 2,
  ResourceUsageType_MIN = ResourceUsageType_Immutable,
  ResourceUsageType_MAX = ResourceUsageType_Stream
};

inline const ResourceUsageType (&EnumValuesResourceUsageType())[3] {
  static const ResourceUsageType values[] = {
    ResourceUsageType_Immutable,
    ResourceUsageType_Dynamic,
    ResourceUsageType_Stream
  };
  return values;
}

inline const char * const *EnumNamesResourceUsageType() {
  static const char * const names[] = {
    "Immutable",
    "Dynamic",
    "Stream",
    nullptr
  };
  return names;
}

inline const char *EnumNameResourceUsageType(ResourceUsageType e) {
  if (e < ResourceUsageType_Immutable || e > ResourceUsageType_Stream) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResourceUsageType()[index];
}

enum IndexType {
  IndexType_Uint16 = 0,
  IndexType_uint32 = 1,
  IndexType_MIN = IndexType_Uint16,
  IndexType_MAX = IndexType_uint32
};

inline const IndexType (&EnumValuesIndexType())[2] {
  static const IndexType values[] = {
    IndexType_Uint16,
    IndexType_uint32
  };
  return values;
}

inline const char * const *EnumNamesIndexType() {
  static const char * const names[] = {
    "Uint16",
    "uint32",
    nullptr
  };
  return names;
}

inline const char *EnumNameIndexType(IndexType e) {
  if (e < IndexType_Uint16 || e > IndexType_uint32) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIndexType()[index];
}

enum TextureType {
  TextureType_Texture1D = 0,
  TextureType_Texture2D = 1,
  TextureType_Texture3D = 2,
  TextureType_Texture_1D_Array = 3,
  TextureType_Texture_2D_Array = 4,
  TextureType_Texture_Cube_Array = 5,
  TextureType_MIN = TextureType_Texture1D,
  TextureType_MAX = TextureType_Texture_Cube_Array
};

inline const TextureType (&EnumValuesTextureType())[6] {
  static const TextureType values[] = {
    TextureType_Texture1D,
    TextureType_Texture2D,
    TextureType_Texture3D,
    TextureType_Texture_1D_Array,
    TextureType_Texture_2D_Array,
    TextureType_Texture_Cube_Array
  };
  return values;
}

inline const char * const *EnumNamesTextureType() {
  static const char * const names[] = {
    "Texture1D",
    "Texture2D",
    "Texture3D",
    "Texture_1D_Array",
    "Texture_2D_Array",
    "Texture_Cube_Array",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureType(TextureType e) {
  if (e < TextureType_Texture1D || e > TextureType_Texture_Cube_Array) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureType()[index];
}

enum ShaderStage {
  ShaderStage_Vertex = 0,
  ShaderStage_Fragment = 1,
  ShaderStage_Geometry = 2,
  ShaderStage_Compute = 3,
  ShaderStage_Hull = 4,
  ShaderStage_Domain = 5,
  ShaderStage_MIN = ShaderStage_Vertex,
  ShaderStage_MAX = ShaderStage_Domain
};

inline const ShaderStage (&EnumValuesShaderStage())[6] {
  static const ShaderStage values[] = {
    ShaderStage_Vertex,
    ShaderStage_Fragment,
    ShaderStage_Geometry,
    ShaderStage_Compute,
    ShaderStage_Hull,
    ShaderStage_Domain
  };
  return values;
}

inline const char * const *EnumNamesShaderStage() {
  static const char * const names[] = {
    "Vertex",
    "Fragment",
    "Geometry",
    "Compute",
    "Hull",
    "Domain",
    nullptr
  };
  return names;
}

inline const char *EnumNameShaderStage(ShaderStage e) {
  if (e < ShaderStage_Vertex || e > ShaderStage_Domain) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShaderStage()[index];
}

enum TextureFilter {
  TextureFilter_Nearest = 0,
  TextureFilter_Linear = 1,
  TextureFilter_MIN = TextureFilter_Nearest,
  TextureFilter_MAX = TextureFilter_Linear
};

inline const TextureFilter (&EnumValuesTextureFilter())[2] {
  static const TextureFilter values[] = {
    TextureFilter_Nearest,
    TextureFilter_Linear
  };
  return values;
}

inline const char * const *EnumNamesTextureFilter() {
  static const char * const names[] = {
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFilter(TextureFilter e) {
  if (e < TextureFilter_Nearest || e > TextureFilter_Linear) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureFilter()[index];
}

enum TextureMipFilter {
  TextureMipFilter_Nearest = 0,
  TextureMipFilter_Linear = 1,
  TextureMipFilter_MIN = TextureMipFilter_Nearest,
  TextureMipFilter_MAX = TextureMipFilter_Linear
};

inline const TextureMipFilter (&EnumValuesTextureMipFilter())[2] {
  static const TextureMipFilter values[] = {
    TextureMipFilter_Nearest,
    TextureMipFilter_Linear
  };
  return values;
}

inline const char * const *EnumNamesTextureMipFilter() {
  static const char * const names[] = {
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureMipFilter(TextureMipFilter e) {
  if (e < TextureMipFilter_Nearest || e > TextureMipFilter_Linear) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureMipFilter()[index];
}

enum TextureAddressMode {
  TextureAddressMode_Repeat = 0,
  TextureAddressMode_Mirrored_Repeat = 1,
  TextureAddressMode_Clamp_Edge = 2,
  TextureAddressMode_Clamp_Border = 3,
  TextureAddressMode_MIN = TextureAddressMode_Repeat,
  TextureAddressMode_MAX = TextureAddressMode_Clamp_Border
};

inline const TextureAddressMode (&EnumValuesTextureAddressMode())[4] {
  static const TextureAddressMode values[] = {
    TextureAddressMode_Repeat,
    TextureAddressMode_Mirrored_Repeat,
    TextureAddressMode_Clamp_Edge,
    TextureAddressMode_Clamp_Border
  };
  return values;
}

inline const char * const *EnumNamesTextureAddressMode() {
  static const char * const names[] = {
    "Repeat",
    "Mirrored_Repeat",
    "Clamp_Edge",
    "Clamp_Border",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureAddressMode(TextureAddressMode e) {
  if (e < TextureAddressMode_Repeat || e > TextureAddressMode_Clamp_Border) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureAddressMode()[index];
}

enum VertexComponentFormat {
  VertexComponentFormat_Float = 0,
  VertexComponentFormat_Float2 = 1,
  VertexComponentFormat_Float3 = 2,
  VertexComponentFormat_Float4 = 3,
  VertexComponentFormat_Byte = 4,
  VertexComponentFormat_Byte4N = 5,
  VertexComponentFormat_UByte = 6,
  VertexComponentFormat_UByte4N = 7,
  VertexComponentFormat_Short2 = 8,
  VertexComponentFormat_Short2N = 9,
  VertexComponentFormat_Short4 = 10,
  VertexComponentFormat_Short4N = 11,
  VertexComponentFormat_MIN = VertexComponentFormat_Float,
  VertexComponentFormat_MAX = VertexComponentFormat_Short4N
};

inline const VertexComponentFormat (&EnumValuesVertexComponentFormat())[12] {
  static const VertexComponentFormat values[] = {
    VertexComponentFormat_Float,
    VertexComponentFormat_Float2,
    VertexComponentFormat_Float3,
    VertexComponentFormat_Float4,
    VertexComponentFormat_Byte,
    VertexComponentFormat_Byte4N,
    VertexComponentFormat_UByte,
    VertexComponentFormat_UByte4N,
    VertexComponentFormat_Short2,
    VertexComponentFormat_Short2N,
    VertexComponentFormat_Short4,
    VertexComponentFormat_Short4N
  };
  return values;
}

inline const char * const *EnumNamesVertexComponentFormat() {
  static const char * const names[] = {
    "Float",
    "Float2",
    "Float3",
    "Float4",
    "Byte",
    "Byte4N",
    "UByte",
    "UByte4N",
    "Short2",
    "Short2N",
    "Short4",
    "Short4N",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexComponentFormat(VertexComponentFormat e) {
  if (e < VertexComponentFormat_Float || e > VertexComponentFormat_Short4N) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexComponentFormat()[index];
}

enum VertexInputRate {
  VertexInputRate_PerVertex = 0,
  VertexInputRate_PerInstance = 1,
  VertexInputRate_MIN = VertexInputRate_PerVertex,
  VertexInputRate_MAX = VertexInputRate_PerInstance
};

inline const VertexInputRate (&EnumValuesVertexInputRate())[2] {
  static const VertexInputRate values[] = {
    VertexInputRate_PerVertex,
    VertexInputRate_PerInstance
  };
  return values;
}

inline const char * const *EnumNamesVertexInputRate() {
  static const char * const names[] = {
    "PerVertex",
    "PerInstance",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexInputRate(VertexInputRate e) {
  if (e < VertexInputRate_PerVertex || e > VertexInputRate_PerInstance) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexInputRate()[index];
}

enum LogicOperation {
  LogicOperation_Clear = 0,
  LogicOperation_Set = 1,
  LogicOperation_Copy = 2,
  LogicOperation_CopyInverted = 3,
  LogicOperation_Noop = 4,
  LogicOperation_Invert = 5,
  LogicOperation_And = 6,
  LogicOperation_Nand = 7,
  LogicOperation_Or = 8,
  LogicOperation_Nor = 9,
  LogicOperation_Xor = 10,
  LogicOperation_Equiv = 11,
  LogicOperation_AndReverse = 12,
  LogicOperation_AndInverted = 13,
  LogicOperation_OrReverse = 14,
  LogicOperation_OrInverted = 15,
  LogicOperation_MIN = LogicOperation_Clear,
  LogicOperation_MAX = LogicOperation_OrInverted
};

inline const LogicOperation (&EnumValuesLogicOperation())[16] {
  static const LogicOperation values[] = {
    LogicOperation_Clear,
    LogicOperation_Set,
    LogicOperation_Copy,
    LogicOperation_CopyInverted,
    LogicOperation_Noop,
    LogicOperation_Invert,
    LogicOperation_And,
    LogicOperation_Nand,
    LogicOperation_Or,
    LogicOperation_Nor,
    LogicOperation_Xor,
    LogicOperation_Equiv,
    LogicOperation_AndReverse,
    LogicOperation_AndInverted,
    LogicOperation_OrReverse,
    LogicOperation_OrInverted
  };
  return values;
}

inline const char * const *EnumNamesLogicOperation() {
  static const char * const names[] = {
    "Clear",
    "Set",
    "Copy",
    "CopyInverted",
    "Noop",
    "Invert",
    "And",
    "Nand",
    "Or",
    "Nor",
    "Xor",
    "Equiv",
    "AndReverse",
    "AndInverted",
    "OrReverse",
    "OrInverted",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogicOperation(LogicOperation e) {
  if (e < LogicOperation_Clear || e > LogicOperation_OrInverted) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogicOperation()[index];
}

enum QueueType {
  QueueType_Graphics = 0,
  QueueType_Compute = 1,
  QueueType_CopyTransfer = 2,
  QueueType_MIN = QueueType_Graphics,
  QueueType_MAX = QueueType_CopyTransfer
};

inline const QueueType (&EnumValuesQueueType())[3] {
  static const QueueType values[] = {
    QueueType_Graphics,
    QueueType_Compute,
    QueueType_CopyTransfer
  };
  return values;
}

inline const char * const *EnumNamesQueueType() {
  static const char * const names[] = {
    "Graphics",
    "Compute",
    "CopyTransfer",
    nullptr
  };
  return names;
}

inline const char *EnumNameQueueType(QueueType e) {
  if (e < QueueType_Graphics || e > QueueType_CopyTransfer) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQueueType()[index];
}

enum CommandType {
  CommandType_BindPipeline = 0,
  CommandType_BindResourceTable = 1,
  CommandType_BindVertexBuffer = 2,
  CommandType_BindIndexBuffer = 3,
  CommandType_Draw = 4,
  CommandType_DrawIndexed = 5,
  CommandType_DrawInstanced = 6,
  CommandType_DrawIndexedInstanced = 7,
  CommandType_CopyResource = 8,
  CommandType_MIN = CommandType_BindPipeline,
  CommandType_MAX = CommandType_CopyResource
};

inline const CommandType (&EnumValuesCommandType())[9] {
  static const CommandType values[] = {
    CommandType_BindPipeline,
    CommandType_BindResourceTable,
    CommandType_BindVertexBuffer,
    CommandType_BindIndexBuffer,
    CommandType_Draw,
    CommandType_DrawIndexed,
    CommandType_DrawInstanced,
    CommandType_DrawIndexedInstanced,
    CommandType_CopyResource
  };
  return values;
}

inline const char * const *EnumNamesCommandType() {
  static const char * const names[] = {
    "BindPipeline",
    "BindResourceTable",
    "BindVertexBuffer",
    "BindIndexBuffer",
    "Draw",
    "DrawIndexed",
    "DrawInstanced",
    "DrawIndexedInstanced",
    "CopyResource",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommandType(CommandType e) {
  if (e < CommandType_BindPipeline || e > CommandType_CopyResource) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommandType()[index];
}

/////////////////////////////////////////////////////////////////////////////////
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DepthStencilOperation FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t fail_;
  int8_t depth_fail_;
  int8_t pass_;
  int8_t func_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthStencilOperationTypeTable();
  }
  DepthStencilOperation() {
    memset(static_cast<void *>(this), 0, sizeof(DepthStencilOperation));
  }
  DepthStencilOperation(StencilOperation _fail, StencilOperation _depth_fail, StencilOperation _pass, ComparisonFunction _func)
      : fail_(flatbuffers::EndianScalar(static_cast<int8_t>(_fail))),
        depth_fail_(flatbuffers::EndianScalar(static_cast<int8_t>(_depth_fail))),
        pass_(flatbuffers::EndianScalar(static_cast<int8_t>(_pass))),
        func_(flatbuffers::EndianScalar(static_cast<int8_t>(_func))) {
  }
  StencilOperation fail() const {
    return static_cast<StencilOperation>(flatbuffers::EndianScalar(fail_));
  }
  StencilOperation depth_fail() const {
    return static_cast<StencilOperation>(flatbuffers::EndianScalar(depth_fail_));
  }
  StencilOperation pass() const {
    return static_cast<StencilOperation>(flatbuffers::EndianScalar(pass_));
  }
  ComparisonFunction func() const {
    return static_cast<ComparisonFunction>(flatbuffers::EndianScalar(func_));
  }
};
FLATBUFFERS_STRUCT_END(DepthStencilOperation, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) RenderTargetBlend FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t blend_enable_;
  int8_t padding0__;
  uint16_t src_blend_;
  uint16_t dst_blend_;
  int8_t blend_operation_;
  int8_t padding1__;
  uint16_t src_blend_alpha_;
  uint16_t dst_blend_alpha_;
  int8_t blend_operation_alpha_;
  int8_t color_write_mask_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RenderTargetBlendTypeTable();
  }
  RenderTargetBlend() {
    memset(static_cast<void *>(this), 0, sizeof(RenderTargetBlend));
  }
  RenderTargetBlend(bool _blend_enable, Blend _src_blend, Blend _dst_blend, BlendOperation _blend_operation, Blend _src_blend_alpha, Blend _dst_blend_alpha, BlendOperation _blend_operation_alpha, int8_t _color_write_mask)
      : blend_enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_blend_enable))),
        padding0__(0),
        src_blend_(flatbuffers::EndianScalar(static_cast<uint16_t>(_src_blend))),
        dst_blend_(flatbuffers::EndianScalar(static_cast<uint16_t>(_dst_blend))),
        blend_operation_(flatbuffers::EndianScalar(static_cast<int8_t>(_blend_operation))),
        padding1__(0),
        src_blend_alpha_(flatbuffers::EndianScalar(static_cast<uint16_t>(_src_blend_alpha))),
        dst_blend_alpha_(flatbuffers::EndianScalar(static_cast<uint16_t>(_dst_blend_alpha))),
        blend_operation_alpha_(flatbuffers::EndianScalar(static_cast<int8_t>(_blend_operation_alpha))),
        color_write_mask_(flatbuffers::EndianScalar(_color_write_mask)) {
    (void)padding0__;
    (void)padding1__;
  }
  bool blend_enable() const {
    return flatbuffers::EndianScalar(blend_enable_) != 0;
  }
  Blend src_blend() const {
    return static_cast<Blend>(flatbuffers::EndianScalar(src_blend_));
  }
  Blend dst_blend() const {
    return static_cast<Blend>(flatbuffers::EndianScalar(dst_blend_));
  }
  BlendOperation blend_operation() const {
    return static_cast<BlendOperation>(flatbuffers::EndianScalar(blend_operation_));
  }
  Blend src_blend_alpha() const {
    return static_cast<Blend>(flatbuffers::EndianScalar(src_blend_alpha_));
  }
  Blend dst_blend_alpha() const {
    return static_cast<Blend>(flatbuffers::EndianScalar(dst_blend_alpha_));
  }
  BlendOperation blend_operation_alpha() const {
    return static_cast<BlendOperation>(flatbuffers::EndianScalar(blend_operation_alpha_));
  }
  int8_t color_write_mask() const {
    return flatbuffers::EndianScalar(color_write_mask_);
  }
};
FLATBUFFERS_STRUCT_END(RenderTargetBlend, 14);

/////////////////////////////////////////////////////////////////////////////////
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DepthStencilState FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t enable_;
  int8_t depth_function_;
  int8_t depth_write_mask_;
  uint8_t stencil_enable_;
  int8_t stencil_read_mask_;
  int8_t stencil_write_mask_;
  DepthStencilOperation front_face_;
  DepthStencilOperation back_face_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthStencilStateTypeTable();
  }
  DepthStencilState() {
    memset(static_cast<void *>(this), 0, sizeof(DepthStencilState));
  }
  DepthStencilState(bool _enable, ComparisonFunction _depth_function, DepthWriteMask _depth_write_mask, bool _stencil_enable, int8_t _stencil_read_mask, int8_t _stencil_write_mask, const DepthStencilOperation &_front_face, const DepthStencilOperation &_back_face)
      : enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_enable))),
        depth_function_(flatbuffers::EndianScalar(static_cast<int8_t>(_depth_function))),
        depth_write_mask_(flatbuffers::EndianScalar(static_cast<int8_t>(_depth_write_mask))),
        stencil_enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_stencil_enable))),
        stencil_read_mask_(flatbuffers::EndianScalar(_stencil_read_mask)),
        stencil_write_mask_(flatbuffers::EndianScalar(_stencil_write_mask)),
        front_face_(_front_face),
        back_face_(_back_face) {
  }
  bool enable() const {
    return flatbuffers::EndianScalar(enable_) != 0;
  }
  ComparisonFunction depth_function() const {
    return static_cast<ComparisonFunction>(flatbuffers::EndianScalar(depth_function_));
  }
  DepthWriteMask depth_write_mask() const {
    return static_cast<DepthWriteMask>(flatbuffers::EndianScalar(depth_write_mask_));
  }
  bool stencil_enable() const {
    return flatbuffers::EndianScalar(stencil_enable_) != 0;
  }
  int8_t stencil_read_mask() const {
    return flatbuffers::EndianScalar(stencil_read_mask_);
  }
  int8_t stencil_write_mask() const {
    return flatbuffers::EndianScalar(stencil_write_mask_);
  }
  const DepthStencilOperation &front_face() const {
    return front_face_;
  }
  const DepthStencilOperation &back_face() const {
    return back_face_;
  }
};
FLATBUFFERS_STRUCT_END(DepthStencilState, 14);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RasterizerState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t fill_mode_;
  int8_t cull_mode_;
  uint8_t front_counter_clockwise_;
  int8_t padding0__;
  int32_t depth_bias_;
  float depth_bias_clamp_;
  float slope_scaled_depth_bias_;
  uint8_t depth_clip_enabled_;
  uint8_t multisample_enabled_;
  uint8_t conservative_;
  int8_t padding1__;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RasterizerStateTypeTable();
  }
  RasterizerState() {
    memset(static_cast<void *>(this), 0, sizeof(RasterizerState));
  }
  RasterizerState(FillMode _fill_mode, CullMode _cull_mode, bool _front_counter_clockwise, int32_t _depth_bias, float _depth_bias_clamp, float _slope_scaled_depth_bias, bool _depth_clip_enabled, bool _multisample_enabled, bool _conservative)
      : fill_mode_(flatbuffers::EndianScalar(static_cast<int8_t>(_fill_mode))),
        cull_mode_(flatbuffers::EndianScalar(static_cast<int8_t>(_cull_mode))),
        front_counter_clockwise_(flatbuffers::EndianScalar(static_cast<uint8_t>(_front_counter_clockwise))),
        padding0__(0),
        depth_bias_(flatbuffers::EndianScalar(_depth_bias)),
        depth_bias_clamp_(flatbuffers::EndianScalar(_depth_bias_clamp)),
        slope_scaled_depth_bias_(flatbuffers::EndianScalar(_slope_scaled_depth_bias)),
        depth_clip_enabled_(flatbuffers::EndianScalar(static_cast<uint8_t>(_depth_clip_enabled))),
        multisample_enabled_(flatbuffers::EndianScalar(static_cast<uint8_t>(_multisample_enabled))),
        conservative_(flatbuffers::EndianScalar(static_cast<uint8_t>(_conservative))),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  FillMode fill_mode() const {
    return static_cast<FillMode>(flatbuffers::EndianScalar(fill_mode_));
  }
  CullMode cull_mode() const {
    return static_cast<CullMode>(flatbuffers::EndianScalar(cull_mode_));
  }
  bool front_counter_clockwise() const {
    return flatbuffers::EndianScalar(front_counter_clockwise_) != 0;
  }
  int32_t depth_bias() const {
    return flatbuffers::EndianScalar(depth_bias_);
  }
  float depth_bias_clamp() const {
    return flatbuffers::EndianScalar(depth_bias_clamp_);
  }
  float slope_scaled_depth_bias() const {
    return flatbuffers::EndianScalar(slope_scaled_depth_bias_);
  }
  bool depth_clip_enabled() const {
    return flatbuffers::EndianScalar(depth_clip_enabled_) != 0;
  }
  bool multisample_enabled() const {
    return flatbuffers::EndianScalar(multisample_enabled_) != 0;
  }
  bool conservative() const {
    return flatbuffers::EndianScalar(conservative_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(RasterizerState, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) BlendState FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t enable_;
  uint8_t separate_blend_;
  RenderTargetBlend render_target_blend0_;
  RenderTargetBlend render_target_blend1_;
  RenderTargetBlend render_target_blend2_;
  RenderTargetBlend render_target_blend3_;
  RenderTargetBlend render_target_blend4_;
  RenderTargetBlend render_target_blend5_;
  RenderTargetBlend render_target_blend6_;
  RenderTargetBlend render_target_blend7_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlendStateTypeTable();
  }
  BlendState() {
    memset(static_cast<void *>(this), 0, sizeof(BlendState));
  }
  BlendState(bool _enable, bool _separate_blend, const RenderTargetBlend &_render_target_blend0, const RenderTargetBlend &_render_target_blend1, const RenderTargetBlend &_render_target_blend2, const RenderTargetBlend &_render_target_blend3, const RenderTargetBlend &_render_target_blend4, const RenderTargetBlend &_render_target_blend5, const RenderTargetBlend &_render_target_blend6, const RenderTargetBlend &_render_target_blend7)
      : enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_enable))),
        separate_blend_(flatbuffers::EndianScalar(static_cast<uint8_t>(_separate_blend))),
        render_target_blend0_(_render_target_blend0),
        render_target_blend1_(_render_target_blend1),
        render_target_blend2_(_render_target_blend2),
        render_target_blend3_(_render_target_blend3),
        render_target_blend4_(_render_target_blend4),
        render_target_blend5_(_render_target_blend5),
        render_target_blend6_(_render_target_blend6),
        render_target_blend7_(_render_target_blend7) {
  }
  bool enable() const {
    return flatbuffers::EndianScalar(enable_) != 0;
  }
  bool separate_blend() const {
    return flatbuffers::EndianScalar(separate_blend_) != 0;
  }
  const RenderTargetBlend &render_target_blend0() const {
    return render_target_blend0_;
  }
  const RenderTargetBlend &render_target_blend1() const {
    return render_target_blend1_;
  }
  const RenderTargetBlend &render_target_blend2() const {
    return render_target_blend2_;
  }
  const RenderTargetBlend &render_target_blend3() const {
    return render_target_blend3_;
  }
  const RenderTargetBlend &render_target_blend4() const {
    return render_target_blend4_;
  }
  const RenderTargetBlend &render_target_blend5() const {
    return render_target_blend5_;
  }
  const RenderTargetBlend &render_target_blend6() const {
    return render_target_blend6_;
  }
  const RenderTargetBlend &render_target_blend7() const {
    return render_target_blend7_;
  }
};
FLATBUFFERS_STRUCT_END(BlendState, 114);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PipelineState FLATBUFFERS_FINAL_CLASS {
 private:
  BlendState blend_state_;
  int16_t padding0__;
  RasterizerState rasterizer_state_;
  DepthStencilState depth_stencil_state_;
  int8_t topology_type_;
  int8_t padding1__;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PipelineStateTypeTable();
  }
  PipelineState() {
    memset(static_cast<void *>(this), 0, sizeof(PipelineState));
  }
  PipelineState(const BlendState &_blend_state, const RasterizerState &_rasterizer_state, const DepthStencilState &_depth_stencil_state, TopologyType _topology_type)
      : blend_state_(_blend_state),
        padding0__(0),
        rasterizer_state_(_rasterizer_state),
        depth_stencil_state_(_depth_stencil_state),
        topology_type_(flatbuffers::EndianScalar(static_cast<int8_t>(_topology_type))),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  const BlendState &blend_state() const {
    return blend_state_;
  }
  const RasterizerState &rasterizer_state() const {
    return rasterizer_state_;
  }
  const DepthStencilState &depth_stencil_state() const {
    return depth_stencil_state_;
  }
  TopologyType topology_type() const {
    return static_cast<TopologyType>(flatbuffers::EndianScalar(topology_type_));
  }
};
FLATBUFFERS_STRUCT_END(PipelineState, 152);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RenderTarget FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t width_;
  uint16_t height_;
  float scale_x_;
  float scale_y_;
  uint16_t format_;
  int16_t padding0__;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RenderTargetTypeTable();
  }
  RenderTarget() {
    memset(static_cast<void *>(this), 0, sizeof(RenderTarget));
  }
  RenderTarget(uint16_t _width, uint16_t _height, float _scale_x, float _scale_y, TextureFormat _format)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)),
        scale_x_(flatbuffers::EndianScalar(_scale_x)),
        scale_y_(flatbuffers::EndianScalar(_scale_y)),
        format_(flatbuffers::EndianScalar(static_cast<uint16_t>(_format))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  uint16_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
  float scale_x() const {
    return flatbuffers::EndianScalar(scale_x_);
  }
  float scale_y() const {
    return flatbuffers::EndianScalar(scale_y_);
  }
  TextureFormat format() const {
    return static_cast<TextureFormat>(flatbuffers::EndianScalar(format_));
  }
};
FLATBUFFERS_STRUCT_END(RenderTarget, 16);

struct RenderPipeline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RenderPipelineTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  const PipelineState *state() const {
    return GetStruct<const PipelineState *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<PipelineState>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct RenderPipelineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(const PipelineState *state) {
    fbb_.AddStruct(RenderPipeline::VT_STATE, state);
  }
  explicit RenderPipelineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderPipelineBuilder &operator=(const RenderPipelineBuilder &);
  flatbuffers::Offset<RenderPipeline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderPipeline>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderPipeline> CreateRenderPipeline(
    flatbuffers::FlatBufferBuilder &_fbb,
    const PipelineState *state = 0) {
  RenderPipelineBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

inline const flatbuffers::TypeTable *BlendTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlendTypeTable
  };
  static const char * const names[] = {
    "Zero",
    "One",
    "SrcColor",
    "InvSrcColor",
    "SrcAlpha",
    "InvSrcAlpha",
    "DestAlpha",
    "InvDestAlpha",
    "DestColor",
    "InvDestColor",
    "SrcAlphaSta",
    "BlendFactor",
    "InvBlendFactor",
    "Src1Color",
    "InvSrc1Color",
    "Src1Alpha",
    "InvSrc1Alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 17, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlendOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlendOperationTypeTable
  };
  static const char * const names[] = {
    "Add",
    "Subtract",
    "RevSubtract",
    "Min",
    "Max"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ColorWriteEnabledTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ColorWriteEnabledTypeTable
  };
  static const char * const names[] = {
    "Red",
    "Green",
    "Blue",
    "Alpha",
    "All"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ComparisonFunctionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ComparisonFunctionTypeTable
  };
  static const char * const names[] = {
    "Never",
    "Less",
    "Equal",
    "LessEqual",
    "Greater",
    "NotEqual",
    "GreaterEqual",
    "Always"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CullModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CullModeTypeTable
  };
  static const char * const names[] = {
    "None",
    "Front",
    "Back"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthWriteMaskTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DepthWriteMaskTypeTable
  };
  static const char * const names[] = {
    "Zero",
    "All"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FillModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FillModeTypeTable
  };
  static const char * const names[] = {
    "Wireframe",
    "Solid",
    "Point"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FrontClockwiseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FrontClockwiseTypeTable
  };
  static const char * const names[] = {
    "True",
    "False"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StencilOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StencilOperationTypeTable
  };
  static const char * const names[] = {
    "Keep",
    "Zero",
    "Replace",
    "IncrSat",
    "DecrSat",
    "Invert",
    "Incr",
    "Decr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureFormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TextureFormatTypeTable
  };
  static const char * const names[] = {
    "UNKNOWN",
    "R32G32B32A32_TYPELESS",
    "R32G32B32A32_FLOAT",
    "R32G32B32A32_UINT",
    "R32G32B32A32_SINT",
    "R32G32B32_TYPELESS",
    "R32G32B32_FLOAT",
    "R32G32B32_UINT",
    "R32G32B32_SINT",
    "R16G16B16A16_TYPELESS",
    "R16G16B16A16_FLOAT",
    "R16G16B16A16_UNORM",
    "R16G16B16A16_UINT",
    "R16G16B16A16_SNORM",
    "R16G16B16A16_SINT",
    "R32G32_TYPELESS",
    "R32G32_FLOAT",
    "R32G32_UINT",
    "R32G32_SINT",
    "R10G10B10A2_TYPELESS",
    "R10G10B10A2_UNORM",
    "R10G10B10A2_UINT",
    "R11G11B10_FLOAT",
    "R8G8B8A8_TYPELESS",
    "R8G8B8A8_UNORM",
    "R8G8B8A8_UNORM_SRGB",
    "R8G8B8A8_UINT",
    "R8G8B8A8_SNORM",
    "R8G8B8A8_SINT",
    "R16G16_TYPELESS",
    "R16G16_FLOAT",
    "R16G16_UNORM",
    "R16G16_UINT",
    "R16G16_SNORM",
    "R16G16_SINT",
    "R32_TYPELESS",
    "R32_FLOAT",
    "R32_UINT",
    "R32_SINT",
    "R8G8_TYPELESS",
    "R8G8_UNORM",
    "R8G8_UINT",
    "R8G8_SNORM",
    "R8G8_SINT",
    "R16_TYPELESS",
    "R16_FLOAT",
    "R16_UNORM",
    "R16_UINT",
    "R16_SNORM",
    "R16_SINT",
    "R8_TYPELESS",
    "R8_UNORM",
    "R8_UINT",
    "R8_SNORM",
    "R8_SINT",
    "R9G9B9E5_SHAREDEXP",
    "D32_FLOAT_S8X24_UINT",
    "D32_FLOAT",
    "D24_UNORM_S8_UINT",
    "D24_UNORM_X8_UINT",
    "D16_UNORM",
    "S8_UINT",
    "BC1_TYPELESS",
    "BC1_UNORM",
    "BC1_UNORM_SRGB",
    "BC2_TYPELESS",
    "BC2_UNORM",
    "BC2_UNORM_SRGB",
    "BC3_TYPELESS",
    "BC3_UNORM",
    "BC3_UNORM_SRGB",
    "BC4_TYPELESS",
    "BC4_UNORM",
    "BC4_SNORM",
    "BC5_TYPELESS",
    "BC5_UNORM",
    "BC5_SNORM",
    "B5G6R5_UNORM",
    "B5G5R5A1_UNORM",
    "B8G8R8A8_UNORM",
    "B8G8R8X8_UNORM",
    "R10G10B10_XR_BIAS_A2_UNORM",
    "B8G8R8A8_TYPELESS",
    "B8G8R8A8_UNORM_SRGB",
    "B8G8R8X8_TYPELESS",
    "B8G8R8X8_UNORM_SRGB",
    "BC6H_TYPELESS",
    "BC6H_UF16",
    "BC6H_SF16",
    "BC7_TYPELESS",
    "BC7_UNORM",
    "BC7_UNORM_SRGB",
    "FORCE_UINT"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 93, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopologyTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TopologyTypeTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "Point",
    "Line",
    "Triangle",
    "Patch"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BufferTypeTypeTable
  };
  static const char * const names[] = {
    "Vertex",
    "Index",
    "Constant",
    "Indirect"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResourceUsageTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ResourceUsageTypeTypeTable
  };
  static const char * const names[] = {
    "Immutable",
    "Dynamic",
    "Stream"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IndexTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    IndexTypeTypeTable
  };
  static const char * const names[] = {
    "Uint16",
    "uint32"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TextureTypeTypeTable
  };
  static const char * const names[] = {
    "Texture1D",
    "Texture2D",
    "Texture3D",
    "Texture_1D_Array",
    "Texture_2D_Array",
    "Texture_Cube_Array"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ShaderStageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ShaderStageTypeTable
  };
  static const char * const names[] = {
    "Vertex",
    "Fragment",
    "Geometry",
    "Compute",
    "Hull",
    "Domain"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TextureFilterTypeTable
  };
  static const char * const names[] = {
    "Nearest",
    "Linear"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureMipFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TextureMipFilterTypeTable
  };
  static const char * const names[] = {
    "Nearest",
    "Linear"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureAddressModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TextureAddressModeTypeTable
  };
  static const char * const names[] = {
    "Repeat",
    "Mirrored_Repeat",
    "Clamp_Edge",
    "Clamp_Border"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VertexComponentFormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    VertexComponentFormatTypeTable
  };
  static const char * const names[] = {
    "Float",
    "Float2",
    "Float3",
    "Float4",
    "Byte",
    "Byte4N",
    "UByte",
    "UByte4N",
    "Short2",
    "Short2N",
    "Short4",
    "Short4N"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 12, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VertexInputRateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    VertexInputRateTypeTable
  };
  static const char * const names[] = {
    "PerVertex",
    "PerInstance"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    LogicOperationTypeTable
  };
  static const char * const names[] = {
    "Clear",
    "Set",
    "Copy",
    "CopyInverted",
    "Noop",
    "Invert",
    "And",
    "Nand",
    "Or",
    "Nor",
    "Xor",
    "Equiv",
    "AndReverse",
    "AndInverted",
    "OrReverse",
    "OrInverted"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 16, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QueueTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    QueueTypeTypeTable
  };
  static const char * const names[] = {
    "Graphics",
    "Compute",
    "CopyTransfer"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CommandTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CommandTypeTypeTable
  };
  static const char * const names[] = {
    "BindPipeline",
    "BindResourceTable",
    "BindVertexBuffer",
    "BindIndexBuffer",
    "Draw",
    "DrawIndexed",
    "DrawInstanced",
    "DrawIndexedInstanced",
    "CopyResource"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthStencilOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StencilOperationTypeTable,
    ComparisonFunctionTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4 };
  static const char * const names[] = {
    "fail",
    "depth_fail",
    "pass",
    "func"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RenderTargetBlendTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_CHAR, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlendTypeTable,
    BlendOperationTypeTable
  };
  static const int64_t values[] = { 0, 2, 4, 6, 8, 10, 12, 13, 14 };
  static const char * const names[] = {
    "blend_enable",
    "src_blend",
    "dst_blend",
    "blend_operation",
    "src_blend_alpha",
    "dst_blend_alpha",
    "blend_operation_alpha",
    "color_write_mask"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 8, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthStencilStateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ComparisonFunctionTypeTable,
    DepthWriteMaskTypeTable,
    DepthStencilOperationTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4, 5, 6, 10, 14 };
  static const char * const names[] = {
    "enable",
    "depth_function",
    "depth_write_mask",
    "stencil_enable",
    "stencil_read_mask",
    "stencil_write_mask",
    "front_face",
    "back_face"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 8, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RasterizerStateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FillModeTypeTable,
    CullModeTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8, 12, 16, 17, 18, 20 };
  static const char * const names[] = {
    "fill_mode",
    "cull_mode",
    "front_counter_clockwise",
    "depth_bias",
    "depth_bias_clamp",
    "slope_scaled_depth_bias",
    "depth_clip_enabled",
    "multisample_enabled",
    "conservative"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 9, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlendStateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RenderTargetBlendTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 16, 30, 44, 58, 72, 86, 100, 114 };
  static const char * const names[] = {
    "enable",
    "separate_blend",
    "render_target_blend0",
    "render_target_blend1",
    "render_target_blend2",
    "render_target_blend3",
    "render_target_blend4",
    "render_target_blend5",
    "render_target_blend6",
    "render_target_blend7"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 10, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PipelineStateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlendStateTypeTable,
    RasterizerStateTypeTable,
    DepthStencilStateTypeTable,
    TopologyTypeTypeTable
  };
  static const int64_t values[] = { 0, 116, 136, 150, 152 };
  static const char * const names[] = {
    "blend_state",
    "rasterizer_state",
    "depth_stencil_state",
    "topology_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RenderTargetTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TextureFormatTypeTable
  };
  static const int64_t values[] = { 0, 2, 4, 8, 12, 16 };
  static const char * const names[] = {
    "width",
    "height",
    "scale_x",
    "scale_y",
    "format"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 5, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RenderPipelineTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PipelineStateTypeTable
  };
  static const char * const names[] = {
    "state"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const rendering::RenderPipeline *GetRenderPipeline(const void *buf) {
  return flatbuffers::GetRoot<rendering::RenderPipeline>(buf);
}

inline const rendering::RenderPipeline *GetSizePrefixedRenderPipeline(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<rendering::RenderPipeline>(buf);
}

inline bool VerifyRenderPipelineBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rendering::RenderPipeline>(nullptr);
}

inline bool VerifySizePrefixedRenderPipelineBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rendering::RenderPipeline>(nullptr);
}

inline void FinishRenderPipelineBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rendering::RenderPipeline> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRenderPipelineBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rendering::RenderPipeline> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace rendering

#endif  // FLATBUFFERS_GENERATED_RENDERDEFINITIONS_RENDERING_H_
